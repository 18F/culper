package geo

import (
	"encoding/xml"
	"fmt"
	"net/http"
	"net/url"
	"strings"
)

const (
	// USPSURI is that base address for the USPS API
	USPSURI = "http://production.shippingapis.com/ShippingAPI.dll"

	// VerifyAPI is the name of that API that handles address verifications
	VerifyAPI = "Verify"
)

// USPSGeocoder geocodes address information using the United States Post Office webservice
// API docs can be found https://www.usps.com/business/web-tools-apis/address-information-api.htm
type USPSGeocoder struct {
	baseURI string
	userID  string
}

// Validate takes values to be geocoded and executes a web service call
func (g USPSGeocoder) Validate(geoValues Values) (Results, error) {
	return g.query(geoValues)
}

// query creates and executes http requests and populates a Results object
func (g USPSGeocoder) query(geoValues Values) (results Results, err error) {
	// Set up query parameters
	v := url.Values{}

	// Populate USPS Address struct with generic geo values
	address := USPSAddress{}
	address.FromGeoValues(geoValues)
	addressRequest := USPSAddressValidateRequest{
		UserID:  g.userID,
		Address: address,
	}

	// Set the api we want to query
	v.Set("API", VerifyAPI)

	// Set the xml containing information to verify
	v.Set("XML", addressRequest.ToXMLString())

	// Query away!
	uri := fmt.Sprintf("%v?%v", g.baseURI, v.Encode())
	resp, err := http.Get(uri)
	if err != nil {
		return nil, err
	}

	// Decode the response to populate struct
	var addressResp USPSAddressValidateResponse
	if err := xml.NewDecoder(resp.Body).Decode(&addressResp); err != nil {
		return nil, err
	}

	// Go through all the results and generate a normalized Result struct from each address
	for _, addr := range addressResp.Address {
		results = append(results, addr.ToResult(geoValues))
	}

	if results.HasErrors() {
		return results, fmt.Errorf("Geocoder returned error information")
	}

	if results.HasPartial() {
		return results, fmt.Errorf("Geocode contains partial matches. Suggestions are available")
	}

	return results, nil
}

// USPSAddressValidateRequest contains the information necessary to execute an address validation webservice request
// The USERID refers to the api key that must be sent with each request
type USPSAddressValidateRequest struct {
	XMLName xml.Name `xml:"AddressValidateRequest"`
	UserID  string   `xml:"USERID,attr"`
	Address USPSAddress
}

// USPSAddressValidateResponse contains the information returned from a successful webservice request
type USPSAddressValidateResponse struct {
	XMLName xml.Name      `xml:"AddressValidateResponse"`
	Address []USPSAddress `xml:"Address"`
}

// ToXMLString creates a string representation of the xml request
func (r USPSAddressValidateRequest) ToXMLString() string {
	output, _ := xml.Marshal(r)
	return string(output)
}

// USPSError is the structure for responses resulting in an error
type USPSError struct {
	// The error number generated by the Web Tools server.
	Number int64 `xml:"Number"`

	// The component and interface that generated the error on the Web Tools server.
	Source string `xml:"Source"`

	// The error description
	Description string `xml:"Description"`

	// [reserved for future use according to USPS docs]
	HelpFile string `xml:"HelpFile"`

	// [reserved for future use according to USPS docs]
	HelpContext string `xml:"HelpContext"`
}

// USPSAddress represents the structure for address information in a USPS request
type USPSAddress struct {

	// XMLName refers to the name to give the XML tag
	XMLName xml.Name `xml:"Address"`
	// Up to 5 address verifications can be included per transaction.
	// <Address ID="0"></Address><Address ID="1"></Address>
	ID int64 `xml:"ID,attr"`

	// Maximum characters allowed: 38
	FirmName string `xml:"FirmName,omitempty"`

	// Address Line 1 is used to provide an apartment or suite number, if applicable.  Maximum characters allowed: 38
	Address1 string `xml:"Address1"`

	// Street address. Maximum characters allowed: 38
	Address2 string `xml:"Address2"`

	// Maximum characters allowed: 15.  Either <City> and <State> or <Zip5> are required.
	City string `xml:"City"`

	// Maximum characters allowed: 2. Either <City> and <State> or <Zip5> are required.
	State string `xml:"State"`

	// Maximum characters allowed: 28. For Puerto Rico addresses only.
	Urbanization string `xml:"Urbanization"`

	// Maximum characters allowed: 5. Either <City> and <State> or <Zip5> are required.
	Zip5 string `xml:"Zip5"`

	// Input tag exactly as presented, not all caps.  Maximum characters allowed:
	Zip4 string `xml:"Zip4"`

	// Stores error information for an address. USPS returns errors within the address block if they
	// exist. We set this to a pointer so that we can check for <nil>
	Error *USPSError `xml:"Error"`

	// Stores additional information that is not necessarily an error. Some instances may include where an apartment
	// number used does not correspond to a valid base address
	ReturnText string `xml:"ReturnText,omitempty"`
}

// FromGeoValues populates a USPSAddress using Values
func (address *USPSAddress) FromGeoValues(geoValues Values) {
	if geoValues.Address != "" {
		address.Address2 = geoValues.Address
	}
	if geoValues.City != "" {
		address.City = geoValues.City
	}
	if geoValues.State != "" {
		address.State = geoValues.State
	}
}

// ToResult generates a Result struct and determines whether it is a partial match. A partial
// match occurs when there's a mismatch in values between each corresponding field
func (address *USPSAddress) ToResult(geoValues Values) (result Result) {
	result.Street = address.Address2
	result.City = address.City
	result.State = address.State
	result.Zipcode = address.Zip5

	// Check if there are deviations between what was requested versus what
	// was returned. If we find any, mark result as Partial
	switch {
	case address.ReturnText != "":
		fallthrough
	case !strings.EqualFold(result.Street, geoValues.Address):
		fallthrough
	case !strings.EqualFold(result.City, geoValues.City):
		fallthrough
	case !strings.EqualFold(result.State, geoValues.State):
		fallthrough
	case !strings.EqualFold(result.Zipcode, geoValues.Zipcode):
		result.Partial = true
	}

	// If an actual Error is returned, we populate from that object. Otherwise,
	// we can populate the content in ReturnText. There will never be an instance where Error
	// and ReturnText values are both populated
	switch {
	case address.Error != nil:
		result.Error = address.Error.Description
	case address.ReturnText != "":
		result.Error = address.ReturnText
	}

	return result
}

// NewUSPSGeocoder creates a new instance of USPS Geocoder
func NewUSPSGeocoder(userID string) *USPSGeocoder {
	return &USPSGeocoder{
		userID:  userID,
		baseURI: USPSURI,
	}
}
